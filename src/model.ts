import { CustomResource } from "sandstone";
import { BlockAxisName, BlockFace, BlockFaceName } from "./block";
import { ResourceLoader } from "./gamedata";
import { Vector, Vector3 } from "./math";
import { getResourcePath, parseNamespacedId, saveResourcepackResource } from "./resource";

export const ModelResource = CustomResource("model", {
	dataType: "json",
	extension: "json",
	save: saveResourcepackResource("assets", "models")
});

/**
 * The maximum custom model data is the maximum integer a float can store
 * without losing precision because the predicate value is internally converted
 * to a float
 */
export const MAX_CUSTOM_MODEL_DATA = 16777216;

/**
 * @see https://minecraft.fandom.com/wiki/Model
 */
export type ModelData = {
	parent?: string;
	/**
	 * Whether to shade the block using ambient occlusion
	 * @see https://en.wikipedia.org/wiki/Ambient_occlusion
	 */
	ambientocclusion?: boolean;
	textures?: ModelData.Textures;
	display?: ModelData.Display;
	elements?: ModelData.Element[];
	overrides?: ModelData.Override[];
};

export namespace ModelData {
	/**
	 * Creates an item model that will be generated by Minecraft
	 * ("minecraft:item/generated")
	 */
	export function generatedItem(...layers: string[]): ModelData {
		if (typeof layers === "string") layers = [layers];
		const textures: Textures = {};
		layers.forEach((texture, idx) => textures[`layer${idx}`] = texture);
		return {
			parent: "minecraft:item/generated"
		};
	}
	export async function load(loader: ResourceLoader, id: string): Promise<ModelData | null> {
		const parsedId = parseNamespacedId(id);
		const rPath = getResourcePath(parsedId, "models", "json");
		const data = await loader.readResourceFile(rPath);
		if (data === null) return null;
		else return JSON.parse(data.toString("utf8"));
	}

	export type Textures =
		& {
			particle?: string;
		}
		& {
			[name: string]: string;
		}
	export enum DisplayPosition {
		ThirdpersonRight = "thirdpirson_righthand",
		ThirdpersonLeft = "thirdpirson_lefthand",
		FirstpersonRight = "firstpirson_righthand",
		FirstpersonLeft = "firstpirson_lefthand",
		Gui = "gui",
		Head = "head",
		Ground = "ground",
		Fixed = "fixed",
	}
	export type Display = Partial<Record<DisplayPosition, DisplayTransform>>;
	export type DisplayTransform = {
		rotation?: [number, number, number];
		translation?: [number, number, number];
		scale?: [number, number, number];
	}
	export type Element = {
		from: [number, number, number];
		to: [number, number, number];
		rotation?: ElementRotation;
		shade?: boolean;
		faces?: ElementFaces;
	}
	export type ElementFaces = {
		down?: ElementFace;
		up?: ElementFace;
		north?: ElementFace;
		east?: ElementFace;
		south?: ElementFace;
		west?: ElementFace;
	}
	export type ElementRotation = {
		origin: [number, number, number];
		axis: BlockAxisName;
		angle: -45 | -22.5 | 0 | 22.5 | 45;
		rescale?: boolean;
	}
	export type ElementFace = {
		texture: `#${string}`;
		uv?: [number, number, number, number];
		cullface?: BlockFaceName;
		rotation?: 0 | 90 | 180 | 270;
		tintindex?: number;
	}
	export type Override = {
		predicate: Partial<Record<OverridePredicate, number>>;
		model: string;
	}
	/** @see https://minecraft.fandom.com/wiki/Model */
	export const enum OverridePredicate {
		/**
		 * Used on compasses to determine the current angle, expressed in a decimal
		 * value of less than one.
		 */
		CompassAngle = "angle",
		/**
		 * Used on shields to determine if currently blocking. If `1`, the player is
		 * blocking.
		 */
		ShieldBlocking = "blocking",
		/**
		 * Used on Elytra to determine if broken. If `1`, the Elytra is broken.
		 */
		Broken = "broken",
		/**
		 * Used on fishing rods to determine if the fishing rod has been cast. If `1`,
		 * the fishing rod has been cast.
		 */
		RodCast = "cast",
		/**
		 * Used on ender pearls and chorus fruit to determine the remaining cooldown,
		 * expressed in a decimal value between `0` and `1`.
		 */
		Cooldown = "cooldown",
		/**
		 * Used on items with durability to determine the amount of damage, expressed
		 * in a decimal value between `0` and `1`.
		 */
		Damage = "damage",
		/**
		 * Used on items with durability to determine if it is damaged. If 1, the item
		 * is damaged. Note that if an item has the unbreakable tag, this may be `0`
		 * while the item has a non-zero `"damage"` tag.
		 */
		Damaged = "damaged",
		/**
		 * Determines the model used by left handed players. It affects the item they
		 * see in inventories, along with the item players see them holding or wearing.
		 */
		Lefthanded = "lefthanded",
		/**
		 * Determines the amount a bow or crossbow has been pulled, expressed in a
		 * decimal value of less than one.
		 */
		BowPull = "pull",
		/**
		 * Used on bows and crossbows to determine if the bow is being pulled. If `1`,
		 * the bow is currently being pulled.
		 */
		BowPulling = "pulling",
		/**
		 * Used on crossbows to determine if they are charged with any projectile.
		 * If `1`, the crossbow is charged.
		 */
		Charged = "charged",
		/**
		 * Used on crossbows. If `1`, the crossbow is charged with a firework rocket.
		 */
		Firework = "firework",
		/**
		 * Used on the trident to determine if the trident is ready to be thrown by
		 * the player. If `1`, the trident is ready for fire.
		 */
		Throwing = "throwing",
		/**
		 * Used on clocks to determine the current time, expressed in a decimal value
		 * of less than one.
		 */
		Time = "time",
		/**
		 * Used on any item and is compared to the `tag.CustomModelData` NBT,
		 * expressed in an integer value. The number is still internally converted to
		 * float, causing a precision loss for some numbers above 16 million. If the
		 * value read from the item data is greater than or equal to the value used
		 * for the predicate, the predicate is positive.
		 */
		CustomModelData = "custom_model_data",
	}
}

/**
 * Helper class for modifying Minecraft model data
 */
export class Model {
	public parent: string | null = null;
	public ambientocclusion: boolean = true;
	public textures: { [name: string]: string } = {};
	public elements: Model.Element[] = [];
	public display: { [type in ModelData.DisplayPosition]?: Model.DisplayTransform } = {};
	public overrides: ModelData.Override[] = [];

	/**
	 * Crates a new empty model
	 */
	public constructor() { }

	/**
	 * Generates the Minecraft model JSON
	 */
	public toJSON(): ModelData {
		let obj: ModelData = {};

		if (this.parent)
			obj.parent = this.parent;
		if (Object.keys(this.textures).length > 0)
			obj.textures = this.textures;
		if (!this.ambientocclusion)
			obj.ambientocclusion = false;
		if (this.elements.length > 0)
			obj.elements = this.elements.map(e => e.toJSON());
		if (Object.keys(this.display).length > 0) {
			obj.display = {};
			(Object.entries(this.display) as [ModelData.DisplayPosition, Model.DisplayTransform][])
				.forEach(([type, t]) => {
					obj.display![type] = t.toJSON();
				});
		}
		if (this.overrides.length > 0)
			obj.overrides = this.overrides;

		return obj;
	}

	/**
	 * Parses the Minecraft model JSON
	 */
	public static fromJSON(data: ModelData): Model {
		let m = new Model();

		if (data.parent)
			m.parent = data.parent;
		if (data.textures)
			m.textures = data.textures;
		if (data.display) {
			Object.values(ModelData.DisplayPosition)
				.filter(t => t in data.display!)
				.forEach(t => {
					m.display[t] = Model.DisplayTransform.fromJSON(data.display![t]!);
				});
		}
		if (typeof data.ambientocclusion === "boolean")
			m.ambientocclusion = data.ambientocclusion;
		if (data.elements)
			m.elements = data.elements.map(Model.Element.fromJSON);
		if (data.overrides)
			m.overrides = data.overrides;

		return m;
	}
}

export namespace Model {

	/**
	 * Helper class for modifying model elements (cubes)
	 */
	export class Element {
		public faces: ModelData.ElementFaces = {};
		public rotation: ModelData.ElementRotation | null = null;
		public shade: boolean = true;

		/**
		 * Creates a new cube without any faces
		 */
		public constructor(
			public from: Vector3,
			public to: Vector3,
		) { }

		public hasFace(face: BlockFace): boolean {
			return face.name in this.faces;
		}
		public get hasFaces(): boolean {
			return Object.keys(this.faces).length > 0;
		}
		public setFace(bface: BlockFace, face: ModelData.ElementFace) {
			this.faces[bface.name] = face;
		}
		public deleteFace(bface: BlockFace) {
			delete this.faces[bface.name];
		}

		/**
		 * Returns a new element with only the filtered faces
		 */
		public filterFaces(
			predicate: (bface: BlockFace, face: ModelData.ElementFace) => boolean
		): Element {
			let clone = this.clone();
			(Object.entries(this.faces) as [BlockFaceName, ModelData.ElementFace][])
				.filter(([fname, face]) => predicate(BlockFace.fromName(fname), face))
				.forEach(([fname, face]) => clone.faces[fname] = face);
			return clone;
		}

		/**
		 * Gets the culling for a face
		 */
		public getFaceCull(face: BlockFace): BlockFace {
			let f = this.faces[face.name];
			return f?.cullface ? BlockFace.fromName(f.cullface) : face;
		}

		/**
		 * Returns a shallow copy of this element
		 */
		public clone(): Element {
			let clone = new Element(this.from, this.to);
			clone.rotation = this.rotation;
			clone.shade = this.shade;
			return clone;
		}

		/**
		 * Generates the Minecraft model JSON
		 */
		public toJSON(): ModelData.Element {
			let obj: ModelData.Element = {
				from: this.from.components,
				to: this.to.components,
			};

			if (Object.keys(this.faces).length > 0)
				obj.faces = this.faces;
			if (this.rotation)
				obj.rotation = this.rotation;
			if (!this.shade)
				obj.shade = false;

			return obj;
		}

		/**
		 * Parses the Minecraft model JSON
		 */
		public static fromJSON(data: ModelData.Element): Element {
			let e = new Element(
				new Vector(data.from),
				new Vector(data.to)
			);

			if (data.faces) e.faces = data.faces;
			if (data.rotation) e.rotation = data.rotation;
			if (data.shade) e.shade = data.shade;

			return e;
		}
	}

	/**
	 * Helper class for modifying the model transformation when displayed
	 */
	export class DisplayTransform {
		public rotation: Vector3 = Vector3.ZERO;
		public translation: Vector3 = Vector3.ZERO;
		public scale: Vector3 = Vector3.ONE;

		public constructor() { }

		/**
		 * Returns a shallow copy of this transform
		 */
		public clone(): DisplayTransform {
			const clone = new DisplayTransform();
			clone.rotation = this.rotation;
			clone.translation = this.translation;
			clone.scale = this.scale;
			return clone;
		}

		public toJSON(): ModelData.DisplayTransform {
			let obj: ModelData.DisplayTransform = {};

			if (this.rotation.every(n => n === 0)) obj.rotation = this.rotation.components;
			if (this.translation.every(n => n === 0)) obj.translation = this.translation.components;
			if (this.scale.every(n => n === 1)) obj.scale = this.scale.components;

			return obj;
		}

		public static fromJSON(data: ModelData.DisplayTransform): DisplayTransform {
			let t = new DisplayTransform();

			if (data.rotation) t.rotation = new Vector(data.rotation);
			if (data.translation) t.translation = new Vector(data.translation);
			if (data.scale) t.scale = new Vector(data.scale);

			return t;
		}
	}
}